<!DOCTYPE html>
<html lang='en'>
  <head>
    <title>Getting Started Guide  Reference</title>
    <link rel='stylesheet' type='text/css' href='css/jazzy.css' />
    <link rel='stylesheet' type='text/css' href='css/highlight.css' />
    <meta charset='utf-8'>
    <script src='js/jquery.min.js' defer></script>
    <script src='js/jazzy.js' defer></script>
  </head>
  <body>


    <a title='Getting Started Guide  Reference'></a>

    <header class='header'>
      <p class='header-col header-col--primary'>
        <a class='header-link' href='index.html'>
          ReSwift Docs
        </a>
         (74% documented)
      </p>
    
        <p class='header-col header-col--secondary'>
          <a class='header-link' href='https://github.com/ReSwift/ReSwift'>
            <img class='header-icon' src='img/gh.png'/>
            View on GitHub
          </a>
        </p>
    
        <p class='header-col header-col--secondary'>
          <a class='header-link' href='dash-feed://http%3A%2F%2FReSwift%2Egithub%2Eio%2FReSwift%2Fmaster%2Fdocsets%2FReSwift%2Exml'>
            <img class='header-icon' src='img/dash.png'/>
            Install in Dash
          </a>
        </p>
    </header>

    <p class='breadcrumbs'>
      <a class='breadcrumb' href='index.html'>ReSwift Reference</a>
      <img class='carat' src='img/carat.png' />
      Getting Started Guide  Reference
    </p>

    <div class='content-wrapper'>
      <nav class='navigation'>
        <ul class='nav-groups'>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Documentation.html'>Documentation</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='about-reswift.html'>About ReSwift</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='why-reswift.html'>Why ReSwift</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='getting-started-guide.html'>Getting Started Guide</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='installation.html'>Installation</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='checking-out-source-code.html'>Checking out Source Code</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='demo.html'>Demo</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='extensions.html'>Extensions</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='example-projects.html'>Example Projects</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='contributing.html'>Contributing</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='credits.html'>Credits</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='get-in-touch.html'>Get in touch</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='changelog.html'>Changelog</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='license.html'>License</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Stores.html'>Stores</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Classes/Store.html'>Store</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/StoreType.html'>StoreType</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/StoreSubscriber.html'>StoreSubscriber</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/AnyStoreSubscriber.html'>AnyStoreSubscriber</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='State.html'>State</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='State.html#/s:P7ReSwift9StateType'>StateType</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Actions.html'>Actions</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Actions.html#/s:P7ReSwift6Action'>Action</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Structs/StandardAction.html'>StandardAction</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/StandardActionConvertible.html'>StandardActionConvertible</a>
              </li>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Actions.html#/s:V7ReSwift11ReSwiftInit'>ReSwiftInit</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Utilities.html'>Utilities</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/Coding.html'>Coding</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Other Classes.html'>Other Classes</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Classes/Subscription.html'>Subscription</a>
              </li>
            </ul>
          </li>
          <li class='nav-group-name'>
            <a class='nav-group-name-link' href='Other Protocols.html'>Other Protocols</a>
            <ul class='nav-group-tasks'>
              <li class='nav-group-task'>
                <a class='nav-group-task-link' href='Protocols/DispatchingStoreType.html'>DispatchingStoreType</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class='main-content'>

        <section class='section'>
          <div class='section-content'>
            
            <h1 id='getting-started-with-reswift' class='heading'>Getting Started with ReSwift</h1>

<p>ReSwift provides the infrastructure for <code>Store</code>s, <code>Action</code>s and <code>Reducer</code>s to enable a unidirectional data flow as shown below.</p>

<p><img src="img/reswift_detail.png" alt=""></p>

<p>The following steps will describe how to set up the individual components for your ReSwift app.</p>
<h1 id='state' class='heading'>State</h1>

<p>The application state is defined in a single data structure which should be a struct. This struct can have other structs as members, that allows you to add different sub-states as your app grows.</p>

<p>The state struct should store your entire application state, that includes the UI state, the navigation state and the state of your model layer.</p>

<p>Here&rsquo;s an example of a state struct as defined in the <a href="https://github.com/ReSwift/CounterExample-Navigation-TimeTravel">Counter Example</a>:</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">AppState</span><span class="p">:</span> <span class="kt">StateType</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">counter</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">navigationState</span> <span class="o">=</span> <span class="kt">NavigationState</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>

<p>There are multiple things to note:</p>

<ol>
<li>Your app state struct needs to conform to the <code>StateType</code> protocol, currently this is just a marker protocol.</li>
<li>If you are including <code>ReSwiftRouter</code> in your project, your app state needs to contain a property of type <code>NavigationState</code>. This is the sub-state the router will use to store the current route.</li>
</ol>
<h2 id='derived-state' class='heading'>Derived State</h2>

<p>Note that you don&rsquo;t need to store derived state inside of your app state. E.g. instead of storing a <code>UIImage</code> you should store a image URL that can be used to fetch the image from a cache or via a download. The app state should store all the information that uniquely identifies the current state and allows it to be reconstructed, but none that can be easily derived.</p>
<h1 id='actions' class='heading'>Actions</h1>

<p>Actions are used to express intended state changes. Actions don&rsquo;t contain functions, instead they provide information about the intended state change, e.g. which user should be deleted.</p>

<p>In your ReSwift app you will define actions for every possible state change that can happen.</p>

<p>Reducers handle these actions and implement state changes based on the information the actions provide.</p>

<p>All actions in ReSwift conform to the <code>Action</code> protocol, which currently is just a marker protocol.</p>

<p>You can either provide custom types as actions, or you can use the built in <code>StandardAction</code>.</p>

<p>The <code>StandardAction</code> has the following structure:</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">StandardAction</span><span class="p">:</span> <span class="kt">Action</span> <span class="p">{</span>
    <span class="c1">// identifies the action</span>
    <span class="k">let</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">String</span>
    <span class="c1">// provides information that is relevant to processing this action</span>
    <span class="c1">// e.g. details about which post should be favorited</span>
    <span class="k">let</span> <span class="nv">payload</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span> <span class="p">:</span> <span class="kt">AnyObject</span><span class="p">]?</span>
    <span class="c1">// this flag is used for serialization when working with ReSwift Recorder</span>
    <span class="k">let</span> <span class="nv">isTypedAction</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>
</code></pre>

<p><strong>For most applications it is recommended to create your own types for actions instead of using <code>StandardAction</code>, as this allows you to take advantage of Swift&rsquo;s type system</strong>.</p>

<p>To provide your own action, simply create a type that conforms to the <code>Action</code> protocol:</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">LikePostAction</span><span class="p">:</span> <span class="kt">Action</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">post</span><span class="p">:</span> <span class="kt">Post</span>
    <span class="k">let</span> <span class="nv">userLikingPost</span><span class="p">:</span> <span class="kt">User</span>
<span class="p">}</span>
</code></pre>

<p>The advantage of using a <code>StandardAction</code> is that it can be serialized; this is required for using the features provided by <a href="https://github.com/ReSwift/ReSwift-Recorder">ReSwift Recorder</a>; such as persisting the application state between app launches.</p>

<p>If you want to use custom types for actions, but still want to be able to make use of the features provided by ReSwift Recorder, you can implement the <code>StandardActionConvertible</code> protocol. This will allow ReSwift to convert your typed actions to standard actions that can then be serialized.</p>

<p>Once ReSwift Recorder&rsquo;s implementation is further along, you will find detailed information  on all of this in its documentation.</p>
<h1 id='reducers' class='heading'>Reducers</h1>

<p>Reducers are the only place in which you should modify application state! Reducers take the current application state and an action and return the new transformed application state. We recommend to provide many small reducers that each handle a subset of your application state.</p>

<p>You can do this implementing a top-level reducer that conforms to the <code>Reducer</code> protocol. This reducer will then call individual functions for each different part of the app state.</p>

<p>Here&rsquo;s an example in which we construct a new state, by calling sub-reducers with different sub-states:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">appReducer</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="kt">Action</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">State</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">State</span><span class="p">(</span>
      <span class="nv">navigationState</span><span class="p">:</span> <span class="nf">navigationReducer</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">?</span><span class="o">.</span><span class="n">navigationState</span><span class="p">),</span>
      <span class="nv">authenticationState</span><span class="p">:</span> <span class="nf">authenticationReducer</span><span class="p">(</span><span class="n">state</span><span class="p">?</span><span class="o">.</span><span class="n">authenticationState</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="n">action</span><span class="p">),</span>
      <span class="nv">repositories</span><span class="p">:</span> <span class="nf">repositoriesReducer</span><span class="p">(</span><span class="n">state</span><span class="p">?</span><span class="o">.</span><span class="n">repositories</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="n">action</span><span class="p">),</span>
      <span class="nv">bookmarks</span><span class="p">:</span> <span class="nf">bookmarksReducer</span><span class="p">(</span><span class="n">state</span><span class="p">?</span><span class="o">.</span><span class="n">bookmarks</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="n">action</span><span class="p">)</span>
   <span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>The <code>Reducer</code> typealias is a method that takes an <code>Action</code> and an <code>State?</code> and returns a <code>State</code>. Typically reducers will be responsible for initializing the application state. When they receive <code>nil</code> as the current state, they should return the initial default value for their portion of the state. In the example above the <code>appReducer</code> delegates all calls to other reducer functions. E.g. the <code>authenticationReducer</code> is responsible for providing the <code>authenticationState</code>.</p>

<p>Here&rsquo;s what the <code>authenticationReducer</code> function that is called from the <code>appReducer</code> looks like:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">authenticationReducer</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">AuthenticationState</span><span class="p">?,</span> <span class="nv">action</span><span class="p">:</span> <span class="kt">Action</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AuthenticationState</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">state</span> <span class="o">=</span> <span class="n">state</span> <span class="p">??</span> <span class="nf">initialAuthenticationState</span><span class="p">()</span>

    <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">_</span> <span class="k">as</span> <span class="kt">SwiftFlowInit</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">case</span> <span class="k">let</span> <span class="nv">action</span> <span class="k">as</span> <span class="kt">SetOAuthURL</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">oAuthURL</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">oAuthUrl</span>
    <span class="k">case</span> <span class="k">let</span> <span class="nv">action</span> <span class="k">as</span> <span class="kt">UpdateLoggedInState</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">loggedInState</span> <span class="o">=</span> <span class="n">action</span><span class="o">.</span><span class="n">loggedInState</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">state</span>
<span class="p">}</span>
</code></pre>

<p>You can see that the <code>authenticationReducer</code> function is a free function. You can define it with any arbitrary method signature, but we recommend that it matches the <code>Reducer</code> typealias (current state and action in, new state out).</p>

<p>This sub-reducer first checks if the state provided is <code>nil</code>. If that&rsquo;s the case, it sets the state to the initial default state. Next, the reducer switches over the provided <code>action</code> and checks its type. Depending on the type of action, this reducer will updated the state differently. This specific reducer is very simple, each action only triggers a single property of the state to update.</p>

<p>Once the state update is complete, the reducer function returns the new state.</p>

<p>After the <code>appReducer</code> has called all of the sub-reducer functions, we have a new application state. <code>ReSwift</code> will take care of publishing this new state to all subscribers.</p>
<h1 id='store-subscribers' class='heading'>Store Subscribers</h1>

<p>Store subscribers are types that are interested in receiving state updates from a store. Whenever the store updates its state it will notify all subscribers by calling the <code>newState</code> method on them. Subscribers need to conform to the <code>StoreSubscriber</code> protocol:</p>
<pre class="highlight swift"><code><span class="kd">protocol</span> <span class="kt">StoreSubscriber</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">newState</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">StoreSubscriberStateType</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>Most of your <code>StoreSubscriber</code>s will be in the view layer and update their representation whenever they receive a new state.</p>
<h2 id='example-with-filtered-subscriptions' class='heading'>Example With Filtered Subscriptions</h2>

<p>Ideally most of our subscribers should only be interested in a very small portion of the overall app state. <code>ReSwift</code> provides a way to subselect the relevant state for a particular subscriber at the point of subscription. Here&rsquo;s an example of subscribing, filtering and unsubscribing as used within a view controller:</p>
<pre class="highlight swift"><code><span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillAppear</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">animated</span><span class="p">)</span>

    <span class="c1">// subscribe when VC appears</span>
    <span class="c1">// we are only interested in repository substate, filter it out of the overall state</span>
    <span class="n">store</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">subcription</span> <span class="k">in</span>
        <span class="n">subcription</span><span class="o">.</span><span class="n">select</span> <span class="p">{</span> <span class="n">state</span> <span class="k">in</span> <span class="n">state</span><span class="o">.</span><span class="n">repositories</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillDisappear</span><span class="p">(</span><span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewWillDisappear</span><span class="p">(</span><span class="n">animated</span><span class="p">)</span>
    <span class="c1">// unsubscribe when VC disappears</span>
    <span class="n">store</span><span class="o">.</span><span class="nf">unsubscribe</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// The `state` argument needs to match the selected substate</span>
<span class="kd">func</span> <span class="nf">newState</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">Response</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">Repository</span><span class="p">]</span><span class="o">&gt;</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="kt">Success</span><span class="p">(</span><span class="n">repositories</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span> <span class="p">{</span>
        <span class="n">dataSource</span><span class="p">?</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">repositories</span>
        <span class="n">tableView</span><span class="o">.</span><span class="nf">reloadData</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>In the example above we only select a single property from the overall application state: a network <code>Response</code> with a list of repositories.</p>

<p>When selecting a substate as part of calling the <code>subscribe</code> method, you need to make sure that the argument of the <code>newState</code> method has the same type as whatever you return from the state subselection in the <code>subscribe</code> method.</p>

<p>When subscribing within a ViewController you will typically update the view from within the <code>newState</code> method.</p>
<h1 id='beyond-the-basics' class='heading'>Beyond the Basics</h1>
<h2 id='asynchronous-operations' class='heading'>Asynchronous Operations</h2>

<p>Conceptually asynchronous operations can simply be treated as state updates that occur at a later point in time. Here&rsquo;s a simple example of how to tie an asynchronous network request to <code>ReSwift</code> state update:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetchGitHubRepositories</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">State</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Action</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="kt">LoggedIn</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">authenticationState</span><span class="o">.</span><span class="n">loggedInState</span>  <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

    <span class="kt">Octokit</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span><span class="o">.</span><span class="n">repositories</span> <span class="p">{</span> <span class="n">response</span> <span class="k">in</span>
        <span class="nf">dispatch_async</span><span class="p">(</span><span class="nf">dispatch_get_main_queue</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="kt">SetRepostories</span><span class="p">(</span><span class="nv">repositories</span><span class="p">:</span> <span class="n">response</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre>

<p>In this example we&rsquo;re using the <code>Octokit</code> library to perform a network request that fetches a users repositories. Within the callback block of the method we dispatch a state update that injects the received repositories into the app state. This will trigger all receivers to be informed about the new state.</p>

<p>Note that the callback block from the network request arrives on a background thread, therefore we&rsquo;re using <code>dispatch_async(dispatch_get_main_queue())</code> to perform the state update on the main thread. <code>ReSwift</code> will call reducers and subscribers on whatever thread you have dispatched an action from. We recommend to always dispatch from the main thread, but <code>ReSwift</code> does not enforce this recommendation. ReSwift <em>will</em> enforce that all Dispatches, Store Subscribes and Store Unsubscribes are on the same thread or serial Grand Central Dispatch queue. Therefore the main dispatch queue works, however the global dispatch queue, being concurrent, will fail.</p>

<p>In many cases your asynchronous tasks will consist of two separate steps:</p>

<ol>
<li>Update UI to show a loading indicator</li>
<li>Refresh the UI once data arrived</li>
</ol>

<p>You can extend the example above, by dispatching a separate action, as soon as the network request starts. The goal of that action is to trigger the UI to update &amp; show a loading indicator.</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">fetchGitHubRepositories</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">State</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Action</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="kt">LoggedIn</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">authenticationState</span><span class="o">.</span><span class="n">loggedInState</span>  <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

    <span class="kt">Octokit</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span><span class="o">.</span><span class="n">repositories</span> <span class="p">{</span> <span class="n">response</span> <span class="k">in</span>
        <span class="nf">dispatch_async</span><span class="p">(</span><span class="nf">dispatch_get_main_queue</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">store</span><span class="o">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="kt">SetRepostories</span><span class="p">(</span><span class="nv">repositories</span><span class="p">:</span> <span class="o">.</span><span class="kt">Repositories</span><span class="p">(</span><span class="n">response</span><span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kt">SetRepositories</span><span class="p">(</span><span class="nv">repositories</span><span class="p">:</span> <span class="o">.</span><span class="kt">Loading</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>In the example above, we&rsquo;re using an <code>enum</code> to represent the different states of a single state slice that depends on a network request (e.g. loading, result available, network request failed). There are many different ways to model states of a network request but it will mostly involve using multiple dispatched actions at different stages of your network requests.</p>
<h2 id='action-creators' class='heading'>Action Creators</h2>

<p>An important aspect of adopting <code>ReSwift</code> is an improved separation of concerns. Specifically, your view layer should mostly be concerned with adopting its representation to match a new app state and for triggering <code>Action</code>s upon user interactions.</p>

<p>The triggering of actions should always be as simple as possible, we want to avoid any sort of complicated business logic in the view. However, in some cases it can be complicated to decide whether an action should be dispatched or not. Instead of checking the necessary state directly in the view or view controller, you can use <code>ActionCreator</code>s to perform a conditional dispatch.</p>

<p>Just like an <code>Action</code> a <code>ActionCreator</code> function can be dispatched to the store. An <code>ActionCreator</code> takes the current application state, and a reference to a store and might or might not return an <code>Action</code>.</p>

<p>An <code>ActionCreator</code> has the following type signature:</p>
<pre class="highlight swift"><code><span class="kd">typealias</span> <span class="kt">ActionCreator</span> <span class="o">=</span> <span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">State</span><span class="p">,</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">StoreType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Action</span><span class="p">?</span>
</code></pre>

<p>A very simple example of an <code>ActionCreator</code> might be:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">doubleValueIfSmall</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">TestAppState</span><span class="p">,</span> <span class="nv">store</span><span class="p">:</span> <span class="kt">Store</span><span class="o">&lt;</span><span class="kt">TestAppState</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Action</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">testValue</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">SetValueAction</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">testValue</span><span class="o">!</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<h2 id='middleware' class='heading'>Middleware</h2>

<p>ReSwift supports middleware in the same way as Redux does, <a href="http://redux.js.org/docs/advanced/Middleware.html">you can read this great documentation on Redux middleware to get started</a>. Middleware allows developers to provide extensions that wrap the <code>dispatch</code> function.</p>

<p>Let&rsquo;s take a look at a quick example that shows how ReSwift supports Redux style middleware.</p>

<p>The simplest example of a middleware, is one that prints all actions to the console. Here&rsquo;s how you can implement it:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">loggingMiddleware</span><span class="p">:</span> <span class="kt">Middleware</span><span class="o">&lt;</span><span class="kt">Any</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="n">dispatch</span><span class="p">,</span> <span class="n">getState</span> <span class="k">in</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">next</span> <span class="k">in</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">action</span> <span class="k">in</span>
            <span class="c1">// perform middleware logic</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>

            <span class="c1">// call next middleware</span>
            <span class="k">return</span> <span class="nf">next</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>The generic in middleware refers to the return type in <code>getState</code>, and needs to be compatible with the <code>State</code> associated type in your <code>Store</code>.</p>

<p>You can define which middleware you would like to use when creating your store:</p>
<pre class="highlight swift"><code><span class="kt">Store</span><span class="p">(</span><span class="nv">reducer</span><span class="p">:</span> <span class="n">reducer</span><span class="p">,</span> <span class="nv">appState</span><span class="p">:</span> <span class="kt">TestStringAppState</span><span class="p">(),</span>
                    <span class="nv">middleware</span><span class="p">:</span> <span class="p">[</span><span class="n">loggingMiddleware</span><span class="p">,</span> <span class="n">secondMiddleware</span><span class="p">])</span>
</code></pre>

<p>The actions will pass through the middleware in the order in which they are arranged in the array passed to the store initializer, however ideally middleware should not make any assumptions about when exactly it is called.</p>

          </div>
        </section>


      </article>
    </div>
    <section class='footer'>
      <p>© 2016 <a class="link" href="https://github.com/ReSwift/ReSwift" target="_blank" rel="external">ReSwift</a>. All rights reserved.</p>
      <p>Generated by <a class='link' href='https://github.com/realm/jazzy' target='_blank' rel='external'>jazzy ♪♫ v0.8.2</a>, a <a class='link' href='http://realm.io' target='_blank' rel='external'>Realm</a> project.</p>
    </section>
  </body>
</div>
</html>
